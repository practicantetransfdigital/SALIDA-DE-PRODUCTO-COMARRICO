<script>

function cambiarPantalla(idPantalla) {
  document.querySelectorAll('.screen').forEach(screen => {
    screen.classList.remove('active');
  });
  document.getElementById(idPantalla).classList.add('active');
  
  // Si cambiamos a la pantalla principal y ya tenemos datos, actualizar la UI
  if (idPantalla === 'mainScreen' && datosCompletos) {
    console.log('ðŸ”„ Actualizando UI con datos existentes...');
    actualizarEstadisticas(datosCompletos.estadisticas || {});
    crearGraficos(datosCompletos.estadisticas || {});
    cargarTabla((datosCompletos.estadisticas && datosCompletos.estadisticas.ultimosRegistros) || []);
  }
}

function mostrarLoading(mostrar) {
  const spinner = document.getElementById('loadingSpinner');
  if (mostrar) {
    spinner.classList.add('active');
  } else {
    spinner.classList.remove('active');
  }
}

function mostrarError(mensaje) {
  const errorDiv = document.getElementById('loginError');
  if (errorDiv) {
    errorDiv.textContent = mensaje;
    errorDiv.style.display = 'block';
  }
}

function limpiarError() {
  const errorDiv = document.getElementById('loginError');
  if (errorDiv) {
    errorDiv.textContent = '';
    errorDiv.style.display = 'none';
  }
}

function formatearFechaSimple(fecha) {
  if (!fecha) return '-';
  
  try {
    // Si ya es una fecha formateada, devolverla tal cual
    if (typeof fecha === 'string' && fecha.match(/\d{2}\/\d{2}\/\d{4}/)) {
      return fecha;
    }
    
    // CORRECCIÃ“N: Manejar diferentes formatos de fecha
    let fechaObj;
    if (fecha.includes('T')) {
      // Si viene con timezone, usar directamente
      fechaObj = new Date(fecha);
    } else {
      // Si es solo fecha, agregar tiempo para evitar problemas de zona horaria
      fechaObj = new Date(fecha + 'T00:00:00');
    }
    
    if (isNaN(fechaObj.getTime())) return fecha;
    
    const dia = String(fechaObj.getDate()).padStart(2, '0');
    const mes = String(fechaObj.getMonth() + 1).padStart(2, '0');
    const aÃ±o = fechaObj.getFullYear();
    
    return `${dia}/${mes}/${aÃ±o}`;
  } catch (error) {
    return fecha;
  }
}


function errorServidor(error) {
  mostrarLoading(false);
  console.error('âŒ Error del servidor:', error);
  mostrarNotificacion('Error del servidor: ' + (error.message || 'Error desconocido'), 'error');
}


function obtenerBadgeEstado(estado) {
  const badges = {
    'En RevisiÃ³n': 'badge-warning',
    'Devuelto': 'badge-success',
    'Pendiente por DevoluciÃ³n': 'badge-error',
    'Procesado': 'badge-info',
    'Destruido': 'badge-error'
  };
  
  return badges[estado] || 'badge-info';
}

function formatearFecha(fecha) {
  if (!fecha) return '-';
  
  // Si ya es una fecha formateada, devolverla tal cual
  if (typeof fecha === 'string' && fecha.match(/\d{2}\/\d{2}\/\d{4}/)) {
    return fecha;
  }
  
  try {
    const d = new Date(fecha);
    if (isNaN(d.getTime())) return fecha;
    
    const dia = String(d.getDate()).padStart(2, '0');
    const mes = String(d.getMonth() + 1).padStart(2, '0');
    const aÃ±o = d.getFullYear();
    const hora = String(d.getHours()).padStart(2, '0');
    const min = String(d.getMinutes()).padStart(2, '0');
    
    return `${dia}/${mes}/${aÃ±o} ${hora}:${min}`;
  } catch (error) {
    console.error('Error formateando fecha:', error, fecha);
    return fecha;
  }
}

function obtenerBadgeEstado(estado) {
  const badges = {
    'En RevisiÃ³n': 'badge-warning',
    'Devuelto': 'badge-success',
    'Pendiente por DevoluciÃ³n': 'badge-info',
    'Procesado': 'badge-info',
    'Destruido': 'badge-error',
    'Vencido': 'badge-error'
  };
  
  return badges[estado] || 'badge-info';
}

function cerrarModalDetalles() {
  document.getElementById('modalDetalles').classList.remove('active');
  registroActual = null;
  pestaniaActual = 'detalles';
}

function calcularTiempoTranscurrido(fecha) {
  if (!fecha) return '-';
  
  try {
    const fechaRegistro = new Date(fecha);
    if (isNaN(fechaRegistro.getTime())) return '-';
    
    const ahora = new Date();
    const diferencia = ahora - fechaRegistro;
    
    const minutos = Math.floor(diferencia / (1000 * 60));
    const horas = Math.floor(minutos / 60);
    const dias = Math.floor(horas / 24);
    
    if (dias > 0) return `${dias} dÃ­a${dias > 1 ? 's' : ''}`;
    if (horas > 0) return `${horas} hora${horas > 1 ? 's' : ''}`;
    if (minutos > 0) return `${minutos} minuto${minutos > 1 ? 's' : ''}`;
    return 'Hace unos momentos';
  } catch (error) {
    return '-';
  }
}

function calcularEstadoVencimiento(fechaRetorno, estadoActual) {
  if (!fechaRetorno || estadoActual === 'Devuelto' || estadoActual === 'Destruido' || estadoActual === 'Procesado') {
    return { texto: 'No aplica', clase: 'badge-info' };
  }
  
  try {
    // CORRECCIÃ“N: Manejar fecha correctamente
    let fecha;
    if (fechaRetorno.includes('T')) {
      fecha = new Date(fechaRetorno);
    } else {
      fecha = new Date(fechaRetorno + 'T00:00:00');
    }
    
    const hoy = new Date();
    hoy.setHours(0, 0, 0, 0);
    
    const diferencia = fecha - hoy;
    const dias = Math.ceil(diferencia / (1000 * 60 * 60 * 24));
    
    if (dias < 0) {
      return { texto: 'VENCIDO', clase: 'badge-error' };
    } else if (dias === 0) {
      return { texto: 'Vence hoy', clase: 'badge-warning' };
    } else if (dias <= 2) {
      return { texto: `Vence en ${dias} dÃ­a${dias > 1 ? 's' : ''}`, clase: 'badge-warning' };
    } else if (dias <= 7) {
      return { texto: `Vence en ${dias} dÃ­as`, clase: 'badge-info' };
    } else {
      return { texto: `Vence en ${dias} dÃ­as`, clase: 'badge-success' };
    }
  } catch (error) {
    return { texto: 'Error cÃ¡lculo', clase: 'badge-error' };
  }
}

// FunciÃ³n para verificar vencimientos automÃ¡ticamente
function verificarVencimientos() {
  if (!datosCompletos || !datosCompletos.registros) return;
  
  const hoy = new Date();
  hoy.setHours(0, 0, 0, 0);
  
  let vencidos = 0;
  let porVencerHoy = 0;
  let porVencerProximos = 0;
  
  datosCompletos.registros.forEach(registro => {
    if (registro.Estado !== 'Devuelto' && registro.Estado !== 'Destruido' && registro.Estado !== 'Procesado') {
      // CORREGIDO: usar "Tiempo Estimado de Retorno"
      const fechaRetorno = new Date(registro['Tiempo Estimado de Retorno']);
      
      if (fechaRetorno < hoy) {
        vencidos++;
      } else if (fechaRetorno.getTime() === hoy.getTime()) {
        porVencerHoy++;
      } else if (fechaRetorno <= new Date(hoy.getTime() + 2 * 24 * 60 * 60 * 1000)) { // PrÃ³ximos 2 dÃ­as
        porVencerProximos++;
      }
    }
  });
  
  // Mostrar notificaciones agrupadas en una sola si hay mÃºltiples alertas
  const alertas = [];
  
  if (vencidos > 0) {
    alertas.push(`âš ï¸ ${vencidos} salida${vencidos > 1 ? 's' : ''} vencida${vencidos > 1 ? 's' : ''}`);
  }
  
  if (porVencerHoy > 0) {
    alertas.push(`ðŸ“… ${porVencerHoy} salida${porVencerHoy > 1 ? 's' : ''} vence${porVencerHoy > 1 ? 'n' : ''} hoy`);
  }
  
  if (porVencerProximos > 0) {
    alertas.push(`â³ ${porVencerProximos} salida${porVencerProximos > 1 ? 's' : ''} vence${porVencerProximos > 1 ? 'n' : ''} en 2 dÃ­as`);
  }
  
  // Mostrar una sola notificaciÃ³n con todas las alertas
  if (alertas.length > 0) {
    const mensaje = `Alertas de vencimiento:\n${alertas.join('\n')}`;
    mostrarNotificacion(mensaje, 'warning');
  }
}

function configurarAutocompletado() {
  const codigoInput = document.getElementById('codigo');
  const nombreInput = document.getElementById('nombreproducto');
  
  codigoInput.addEventListener('input', function() {
    const codigo = this.value.trim().toUpperCase();
    
    if (productosBase[codigo]) {
      // Si el cÃ³digo existe, autocompletar nombre
      nombreInput.value = productosBase[codigo];
    } else if (codigo === '') {
      // Si se borra el cÃ³digo, limpiar nombre
      nombreInput.value = '';
    }
    // Si no existe, dejar que el usuario escriba manualmente
  });
  
  // TambiÃ©n autocompletar al perder el foco (por si acaso)
  codigoInput.addEventListener('blur', function() {
    const codigo = this.value.trim().toUpperCase();
    if (productosBase[codigo] && !nombreInput.value) {
      nombreInput.value = productosBase[codigo];
    }
  });
}

function buscarProducto(codigo) {
  codigo = codigo.trim().toUpperCase();
  
  // BÃºsqueda exacta
  if (productosBase[codigo]) {
    return productosBase[codigo];
  }
  
  // BÃºsqueda por coincidencia parcial
  for (let key in productosBase) {
    if (key.includes(codigo) || codigo.includes(key)) {
      return productosBase[key];
    }
  }
  
  return null;
}

function llenarSelect(selectId, opciones) {
  const select = document.getElementById(selectId);
  if (!select || !opciones || !Array.isArray(opciones)) {
    console.error(`âŒ No se pudo llenar select ${selectId}`, opciones);
    return;
  }
  
  // Limpiar opciones existentes (excepto la primera si existe)
  select.innerHTML = '';
  
  opciones.forEach(opcion => {
    const option = document.createElement('option');
    option.value = opcion;
    option.textContent = opcion;
    select.appendChild(option);
  });
}

</script>